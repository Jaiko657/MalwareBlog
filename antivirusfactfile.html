<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />

    <title>
        Overview of AntiVirus Capabilities
    </title>
</head>

<body>
    <header>
        <div class="container">
            <a id="a-title" href="home.html">
                <h1>Malware Creation</h1>
            </a>
            <h2>AntiVirus Capabilities</h2>

        </div>
    </header>

    <div class="container">
        <section id="main_content">
            <br>
            <h2>Anti-Virus Protections and Common Bypasses</h2>
            <h3>Types of protections</h3>
            <p>Anti-Virus has evolved since the early days of computers. Originally they just checked files against a database of known malware, this was called static analysis and was good at stopping known malware and is still used today. However, if a
                new malware came along there was nothing it could do to detect it.</p>
            <p>This is when what we call <b><i>Endpoint Detection and Response (EDR)</i></b> expanded upon this basic Anti-Virus idea. This was effectively a combination of lots of different types of protections as well as the initial idea of original anti-viruses
                in static analysis.</p>
            <p>Security researchers commonly use EDR and AV to mean the same thing but they often just mean the collection of techniques that are used together to protect systems.</p>
            <p>These systems all together then are used to give each program a probability of being malware or benign. If for example, a file is doing things that are commonly used by malware the probability of it being a malware is increased. The EDR will
                then combine these scores and try to tag whether it is a dangerous program or not. This is a fine balance as normal programs often use the same ideas as malware to do things that they should be allowed to do. Therefore, inherently malware
                has an advantage as the EDR has to detect as many dangerous programs and with as few possible false possibles. This is effectively a balancing act and due to this; there will always be some malware that will get through as its score is
                similar to normal programs. This is the goal of the malware developer.</p>
            <br>
            <h4>Goal</h4>
            <p>The goal of malware creation is to combine multiple techniques so that the current EDR protections are useless against the malware. Examples of this are plentiful however all of them are now detected as when they are released publicly they
                are then tagged by EDR manufactures so that they will no longer work</p>
            <p>Researching past examples of malware that worked well is a good start to begin thinking in the mindset of someone who develops malware.</p>
            <br>
            <h5>Examples of Protections</h5>

            <ul>
                <li>
                    <h3>Static Analysis</h3>
                </li>
                <p>This is effectively a on disk attempt at comparing programs to a massive database of known malware. If a new malware is created from scratch it will bypass this easily however often there is a part of the malware that is used by multiple
                    different malware. This is called a stub. New <b><i>Static Analysis</i></b> techniques do not need most of the file to be the same but can tag just small sections of the code and then block/quarantine them</p>
                <h5>Bypass</h5>
                <p>To get around <b><i>Static Analysis</i></b> the parts of the code that are dangerous are encoded so that they look completely different and only when the program is run is it actually decoded into the harmful code.
                </p>
                <p>This works well however this gives the file an appearance of being random bits. Another part of the EDR often then will trigger watches the entropy(randomness) of the program. This will increase the score that EDR gives it and could push
                    the file over the threshold that is said to be dangerous</p>
                <img src="img/Entropy.png" alt="">
                <br>
                <br>
                <h5>Entropy Bypass </h5>
                <p>This entropy score can be artificially reduced by adding low entropy data such as photos to the binary. Then the malware will appear to have a similar score as normal programs. This is a example of the arm race between malware detectors
                    and malware developers</p>

                <li>
                    <h3>Sandboxing</h3>
                </li>
                <p>This is where a program is run initially in a environment where it is monitored very heavily. This is used by EDR's to understand what the program wants to do when it is run. However, due to the competition of different EDR's this usually
                    only lasts the first 0.25seconds (first million instructions)</p>
                <p>The reason it is only run for a short period is because running in this sandbox significantly slows down the program. If a user installs a EDR and all of a sudden everything is much slower they will not be happy.
                </p>
                <h5>Bypass</h5>
                <p>Often a sleep function is used to delay the main malicious code from running during this time. However, this is now a bad idea as the EDR will realise that it is being bypassed and increase the score also. Often doing calculations that
                    take time to do is used such as large prime numbers or hash generation is used to delay this.</p>
                <p>This can be combined with the encryption/encoding and the result of this calculation is used as key to decrypt the encoded payload of the malware</p>

                <img style="float: right" src="img/imports.png" alt="">
                <li>
                    <h3>Import Table Analysis</h3>
                </li>
                <p>Each program has a list of functions it imports/uses inside it. Certain functions are used maliciously in malware. Thus, EDR monitors what the program imports and uses, if these are suspicious then the score of the malware will be increased.
                    The photo shows some suspicious imports from basic malware.</p>
                <h5>Bypass</h5>
                <p>Instead of calling these functions through the Windows API we call them directly using pointers to the memory area that the function is. However, This uses code that is very similar each time, this leads it to being caught by the <b><i>Static Analysis</i></b>                    of the EDR</p>
                <p>This is a good place to mention that the protection of the EDR is effectively a mesh. Each protection is to make it harder to do whatever you want and often the bypass to one protection can be detected by another protection. This shows
                    the great work that ethical hackers have done to combine methods together to get around each one of these.</p>
                <p>Developing malware can be very difficult as often when the malware is detected the developer doesn't actually know what set the program over the threshold of being a dangerous program. This means that a lot of trial and error is needed
                    to create a undetectable malware.</p>

                <li>
                    <h3>Event Tracing for Windows</h3>
                </li>
                <p>This is one of the many types of behavior analysis used by EDR's to understand what a program does. The idea is that each action that the program does is then logged and can be seen by the EDR. The EDR then can decide depending on rules
                    whether what the program is doing should be allowed or whether it is suspicious.
                </p>
                <p>Effectively every time our program does any thing it is sent to the EDR so it can understand what it is doing
                </p>
                <h5>Bypass</h5>
                <p>This can be bypassed by patching the function that sends the message to the EDR. This is done by simply changing what the first instruction of the function that sends messages to the EDR (called EtwEventWrite). This instruction is set
                    to return 0 and therefore the rest of the function is not completed so the EDR gets no information about what the program does.</p>
                <p>This can still be detected by the EDR as often if a program that is running does not send back messages to the EDR every so often it is suspicious. Even this can be gotten around by sending completely fake logs to the EDR however this
                    is a lot harder.</p>

                <li>
                    <h3>Removing Hooks</h3>
                </li>
                <p>As discussed all programs use other functions of the operating system to do things. These are stored in what are called DLL's but this is not that important. These DLL's are loaded into the program when it is ran. However, the EDR then
                    patches the loaded DLL's with its own code. This effectively makes every function first go through the EDR and then if it is safe then it is ran. This is called hooking.</p>
                <img src="img/hooking.png" alt="">
                <h5>Bypass</h5>
                <p>The idea is to bypass the red arrows in diagram so EDR can't see what we do.</p>
                <p>This can be bypassed by reloading the DLL's from disk after the program has been loaded. This will overwrite the patch the EDR has and will then allow functions to be called without the EDR monitoring them
                </p>
                <p>Again sandboxing and Import Table Analysis are used by the EDR to stop this. Each part of the EDR makes another part of the EDR harder to be bypassed. Each part is simple to bypass on its own but its the combination of them that makes
                    it difficult</p>

                <li>
                    <h3>In-Memory Detection</h3>
                </li>
                <p>When we have an <b><i>Implant</i></b> (malware that controls PC) 99% of the time the program is doing nothing. When it is sleeping the implant is vulnerable to memory scanning techniques. When sleeping the implant has a pointer to it sitting
                    in the thread stack. This can easily be detected by the EDR due to it sitting in thread stack.
                </p>
                <h5>Bypass</h5>
                <p>Our malware wants to distance itself from this return address. Often we hook the sleep function and then call the hook instead of the actual sleep function</p>
                <p>Another technique is before we sleep we set our implant in memory to what is called
                    <b><i>NO_ACCESS</i></b>. This does what you expect and makes the memory unreadable to anything. However when sleep function finished and tries to run the NO_ACCESS code it causes an error. The real bypass is to then add some code that
                    handles this error. This is called <b><i>Vectored Exception Handling</i></b>, this code should then set the implant memory to READ_EXECUTABLE and then tries to run it again
                </p>
                <p>We can combine encryption to this method as well and before setting NO_ACCESS we encrypt and after we set it back to READ_EXECUTABLE we decrypt it before running again.</p>
            </ul>
            <h2>Summary</h2>
            <p>
                EDR solutions protect endpoint devices from malware and other cyber threats. It's important for those in the cybersecurity field to understand EDR and malware, and stay informed about the latest threats and solutions. This knowledge will help them defend
                against malware and contribute to the overall security of organizations and their endpoint devices.
            </p>
            <h2>Conclussion</h2>
            <p>
                EDR and malware are crucial in modern cybersecurity. A strong understanding of EDR and malware is important for those starting a career in cybersecurity, as they need to be informed and proactive in the face of evolving threats. By staying informed, they
                can defend against malware and improve endpoint security.
            </p>
            <h3>Sources</h3>
            <a href="https://0xpat.github.io/">0xPat Blog</a>
        </section>
    </div>
    <hr>
    <footer>
        <nav>
            <a href="index.html" class="footer-link" id="bottom-link-alt">Home</a>
            <a href="developmentsetup.html" class="footer-link" id="bottom-link">Development and Testing Setup</a>
            <a href="antivirusfactfile.html" class="footer-link" id="bottom-link">Antivirus Fact File</a>
            <a href="WindowsAPl.html" class="footer-link" id="bottom-link-alt">Windows API</a>
            <a href="processesthreadshandles.html" class="footer-link" id="bottom-link-alt">Processes, Threads, and Handles</a>
            <a href="processinjection.html" class="footer-link" id="bottom-link">Process Injection</a>
            <a href="DynamicImports.html" class="footer-link" id="bottom-link">Dynamic Imports</a>
            <a href="installingnim.html" class="footer-link" id="bottom-link-alt">Installing Nim</a>
            <a href="basicnimshell.html" class="footer-link" id="bottom-link-alt">Basic Nim Shell</a>
            <a href="obfuscatingnimshell.html" class="footer-link" id="bottom-link">Obfuscating Nim Shell</a>
            <a href="customencoder.html" class="footer-link" id="bottom-link">Custom Encoder</a>
            <a href="Nimjector.html" class="footer-link" id="bottom-link-alt">Custom Modular Malware</a>
        </nav>
    </footer>
</body>

</html>