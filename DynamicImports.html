<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />

    <title>Dynamic Importing of Windows API Functions</title>
</head>

<body>
    <header>
        <div class="container">
            <a id="a-title" href="home.html">
                <h1>Malware Creation</h1>
            </a>
            <h2>Dynamic Importing of Windows API Functions</h2>
        </div>
    </header>

    <div class="container">
        <section id="main_content">
            <h1>Windows API Import Address Table</h1>
            <br />
            <h2>I. Understanding the Import Address Table (IAT)</h2>
            <p>
                The IAT is a data structure in Portable Executable (PE) files used by Windows operating systems to manage imported functions from dynamic-link libraries (DLLs). When a program is loaded into memory, the loader resolves the addresses of the imported functions
                and populates the IAT with these addresses.
            </p>
            <p>For all windows programs the windows API's associated DLL's are included in the import table by default. However when using certain suspicious functions such as VirtualAllocEx or CreateRemoteThread the EDR marks this as suspicious.</p>

            <h2>EDR Bypass Techniques</h2>

            <ul>
                <li>
                    API Redirection: By manipulating the IAT, a malware developer can redirect the API calls to a custom implementation that bypasses the EDR's monitoring.
                </li>
                <li>
                    Dynamic Import: Malware can delay the loading of a suspicious DLL or the resolution of an API function until the EDR has been disabled or bypassed.
                </li>
                <li>
                    IAT Obfuscation: Scrambling or encrypting the IAT can make it harder for EDRs to analyze the PE file or detect the hooked functions.
                </li>
            </ul>
            <h2>Why use Dynamic Improrting</h2>
            <p>
                EDR's often look at the IAT for suspicious imports, this information is then used to make educated guess of the function of a piece of software. As malware manufactures have found a way of using functions in DLL's without them being included in the IAT.
                This is called <b>dynamic imports</b>, this is achieved by loading the dll into the program during execution and then accessing the addresses of the functions using GetProcAddress().
            </p>
            <p>
                However, EDRs have already developed countermeasures to detect dynamic imports, making it less effective over time. Malware developers are now incorporating multiple techniques such as direct syscalls and WINAPI hashing to get around these new detections.
            </p>
            <h2>Example of Dynamic Import</h2>
            <p>Dynamic linking is the process of importing libraries at runtime allowing the program to use a function without it appearing in the IAT.</p>
            <p>This allows suspicious WINAPI calls to not appear in the IAT for the EDR to question.</p>
            <pre>HMODULE hNtdll = LoadLibrary(TEXT("ntdll.dll"));</pre>
            <p>This code uses loadLibrary to load the library ntdll into the program at runtime. It then gives us a handle to that library called hNTDLL.</p>
            <pre>pNtOpenProcess NtOpenProcess = (pNtOpenProcess)GetProcAddress(hNtdll, "NtOpenProcess");
pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
pNtWriteVirtualMemory NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
pNtProtectVirtualMemory NtProtectVirtualMemory = (pNtProtectVirtualMemory)GetProcAddress(hNtdll, "NtProtectVirtualMemory");
pNtCreateThreadEx NtCreateThreadEx = (pNtCreateThreadEx)GetProcAddress(hNtdll, "NtCreateThreadEx");</pre>
            <p>This section of code then uses GetProcAddress function to obtain the addresses of the functions that are needed relative to the hNTDLL handle.</p>
            <p>We now have everything we need to use these functions however to make them usable as normal functions (HANDLE handle = pNtOpenProcess() etc) we must declare the function pointers.</p>
            <pre>// Declare function pointers for dynamically loaded WinAPI functions
typedef NTSTATUS(NTAPI *pNtOpenProcess)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PCLIENT_ID);
typedef NTSTATUS(NTAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG_PTR, PSIZE_T, ULONG, ULONG);
typedef NTSTATUS(NTAPI *pNtWriteVirtualMemory)(HANDLE, PVOID, CONST PVOID, SIZE_T, PSIZE_T);
typedef NTSTATUS(NTAPI *pNtProtectVirtualMemory)(HANDLE, PVOID *, PSIZE_T, ULONG, PULONG);
typedef NTSTATUS(NTAPI *pNtCreateThreadEx)(PHANDLE, ACCESS_MASK, PVOID, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PVOID);
</pre>
            <p>These functions can now be used throughout the rest of the code without them appearing in the IAT to begin with. However, this is a poor mans implementation and new EDR's can easily detect this approach. The idea however is to take this idea
                and incorporating multiple other techniques together to achieve undetectable malware.</p>


            <h2>Conclusion</h2>
            <p>
                In conclusion, the Import Address Table (IAT) can be leveraged by malware developers to bypass Endpoint Detection and Response (EDR) systems through IAT manipulation. To evade EDRs, malware developers can use various IAT manipulation techniques, dynamic
                import, and IAT obfuscation. However, there are limitations to IAT manipulation, and EDRs have developed countermeasures to detect such attacks. Nevertheless, understanding the IAT and its vulnerabilities is crucial for effective malware
                creation and prevention.
            </p>
            <h3>Sources:</h3>
            <a href="https://snovvcrash.rocks/">Russian But a Great Resource</a>
        </section>
    </div>
    <hr>
    <footer>
        <nav>
            <a href="index.html" class="footer-link" id="bottom-link-alt">Home</a>
            <a href="developmentsetup.html" class="footer-link" id="bottom-link">Development and Testing Setup</a>
            <a href="antivirusfactfile.html" class="footer-link" id="bottom-link">Antivirus Fact File</a>
            <a href="WindowsAPl.html" class="footer-link" id="bottom-link-alt">Windows API</a>
            <a href="processesthreadshandles.html" class="footer-link" id="bottom-link-alt">Processes, Threads, and Handles</a>
            <a href="processinjection.html" class="footer-link" id="bottom-link">Process Injection</a>
            <a href="DynamicImports.html" class="footer-link" id="bottom-link">Dynamic Imports</a>
            <a href="installingnim.html" class="footer-link" id="bottom-link-alt">Installing Nim</a>
            <a href="basicnimshell.html" class="footer-link" id="bottom-link-alt">Basic Nim Shell</a>
            <a href="obfuscatingnimshell.html" class="footer-link" id="bottom-link">Obfuscating Nim Shell</a>
            <a href="customencoder.html" class="footer-link" id="bottom-link">Custom Encoder</a>
            <a href="Nimjector.html" class="footer-link" id="bottom-link-alt">Custom Modular Malware</a>
        </nav>
    </footer>
</body>

</html>