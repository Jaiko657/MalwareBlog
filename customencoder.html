<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />

  <title>
    Word to Hex Encryption
  </title>
</head>

<body>
  <header>
    <div class="container">
      <a id="a-title" href="home.html">
        <h1>Malware Creation</h1>
      </a>
      <h2>Encoder and Decoder</h2>
    </div>
    <div style="float: right;"><button style="background-color: black; font-size: 1em; margin-right: 2em;">
        <a href="https://github.com/">Github Repo </a>
      </button></div>
  </header>

  <div class="container">
    <section id="main_content">
      <h1>Introduction:</h1>

      <p>Encoding shellcode as words or other non-executable formats can be a useful technique for bypassing certain
        types of endpoint detection and response (EDR) systems.
      </p>
      <p>
        EDR systems typically rely on identifying known malicious code patterns or behavior to detect and prevent
        malware. By encoding shellcode into a non-executable format, the code's patterns and behavior can be obfuscated,
        making it more difficult for EDR systems to detect.
      </p>
      <p>
        In this case, encoding shellcode as words, can help disguise the code's purpose and make it more difficult to
        detect. If the code is written in a way that appears innocuous, such as using language-like constructs, it may
        not raise any red flags with EDR systems that are scanning for more obvious indicators of malicious activity.
      </p>
      <p>
        However, it's worth noting that encoding shellcode is just one technique that attackers may use to evade
        detection, and it's not foolproof. This is because EDR systems are multilayered approach and do not solely rely
        on static analysis of the file. This means that other techniques must be used in order to get around EDR
        completely.
      </p>
      <h1>My Code:</h1>
      <h2>The Encoder</h2>
      <p>To start with we need some way of taking the raw shellcode bytes and turning them into something else. This is
        done prior to compiling the binary and such can be done in whatever language I wanted. Therefore, I chose to use
        python to write the encoder. I have never actually used python but it is really simple as I have programmed in
        javascript mainly.</p>
      <p>The ideas of my encoder was to store the hex values of the shellcode as words such as:</p>
      <pre>0x10 -> one zero
0xf6 -> fruit six
</pre>
      <p>There are multiple different formats of normal hex that I will need to convert so I made the script have a
        couple of different ways of reading the file. These are:</p>
      <ul>
        <li><b>default</b> 0x74, 0x2e</li>
        <li><b>raw</b> f3, 9a</li>
        <li><b>escaped</b> \\45\\e1</li>
      </ul>
      <p>The script takes 2 arguments:</p>
      <ul>
        <li>The file location/name</li>
        <li>format (default: 0x13)</li>
      </ul>
      <h2>Python Code Overview:</h2>

      <p>The code effectively parses the file in the format that is decided earlier. This finishes with a list of
        strings that represent the hex values of the entire shellcode.</p>
      <p>Then the list is passed to encrypt function. This function takes the list and loops over the strings separating
        the first and second character and comparing them to a hashmap. it then adds the corresponding word to a list
        and can randomize the most common zero nugget of shellcode to other words if needed.</p>
      <p>After doing this the script then prints out the encoded shellcode and the size of the shellcode(needed
        sometimes).</p>

      <h1>The Decoder:</h1>
      <p>This C++ code decodes a sequence of strings using a pre-defined map of words to hexadecimal digits, and then
        converts the resulting decoded strings to an array of unsigned 8-bit integers (<code>uint8_t</code>).</p>
      <pre>std::string decode_word(const std::string &encoded)
{
    static const std::map<std::string, char> hex_to_word = {
        {"zero", '0'}, {"one", '1'}, {"two", '2'}, {"three", '3'}, {"four", '4'}, {"five", '5'}, {"six", '6'}, {"seven", '7'}, {"eight", '8'}, {"nine", '9'}};

    std::vector<std::string> words;
    size_t pos = encoded.find(' ');
    words.push_back(encoded.substr(0, pos));
    words.push_back(encoded.substr(pos + 1));

    std::string decoded;
    for (const auto &word : words)
    {
        if (hex_to_word.count(word))
        {
            decoded += hex_to_word.at(word);
        }
        else
        {
            decoded += word[0];
        }
    }
    return decoded;
}</pre>
      <p>The <strong>decode_word</strong> function takes a string encoded using the mapping of words to hexadecimal
        digits in the <code>hex_to_word</code> map, and returns the decoded string. If a word in the encoded string is
        not found in the map, the function simply takes the first character of that word as the decoded character.</p>
      <p>The <strong>decode_words</strong> function takes a vector of encoded strings, calls
        <strong>decode_word</strong> on each of them, and returns a vector of the resulting decoded strings.
      </p>
      <p>At this stage we have a decoded payload, however instead of an contiguous array of hex values we have a vector
        of strings. This means we need a way to turn this into raw values.</p>
      <p>In this implementation i used <code>std::uint8_t</code> to store the values.</p>
      <pre>uint8_t hexToUInt8(std::string hexValue)
{
    uint8_t result = 0;
    for (const auto &c : hexValue)
    {
        result <<= 4;
        if (c >= '0' && c <= '9')
        {
            result |= (c - '0');
        }
        else if (c >= 'a' && c <= 'f')
        {
            result |= (c - 'a' + 10);
        }
        else if (c >= 'A' && c <= 'F')
        {
            result |= (c - 'A' + 10);
        }
        else
        {
            throw std::invalid_argument("Invalid hex character: " + c);
        }
    }
    return result;
}</pre>
      <p>The <strong>hexToUInt8</strong> function takes a string representing a hexadecimal digit and returns the
        corresponding unsigned 8-bit integer value.</p>
      <p>The <strong>convertStringsToUint8</strong> function takes a vector of strings and a pointer to an array of same
        size of vector and runs turns the strings eg: "1f" into the uint8_t values.
      </p>
      <p>The plan is then to implement this into the <a href="processinjection.html">process injection</a> code as the
        way of storing the payload.</p>
    </section>
  </div>
  <hr>
  <footer>
    <nav>
      <a href="home.html" class="footer-link" id="home-link">Home</a>
      <a href="installingnim.html" class="footer-link" id="installingnim-link">Installing Nim</a>
      <a href="basicnimshell.html" class="footer-link" id="basicnimshell-link">Basic Nim Shell</a>
      <a href="obfuscatingnimshell.html" class="footer-link" id="obfuscatingnimshell-link">Obfuscating Nim
        Shell</a>
      <a href="processinjection.html" class="footer-link" id="processinjection-link">Process Injection</a>
      <a href="customencoder.html" class="footer-link" id="customencoder-link">Custom Encoder</a>
      <a href="developmentsetup.html" class="footer-link" id="developmentsetup-link">Development Setup</a>
      <a href="antivirusfactfile.html" class="footer-link" id="antivirusfactfile-link">Antivirus Fact File</a>
    </nav>
  </footer>
</body>

</html>